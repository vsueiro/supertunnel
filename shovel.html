<!DOCTYPE html>
<html translate="no">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>TunnelSimulator — Shovel Attachment</title>

    <style>

    * {
      overflow: hidden
    }

    html {
      background: black;
      color: white;
    }

    canvas {
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: block;
      z-index: -1;
    }

    </style>

  </head>
  <body>

    <canvas class="canvas"></canvas>
    <button class="track">Enable motion sensor</button>
    <pre></pre>

    <!-- https://unpkg.com/browse/three@0.124.0/build/three.min.js -->
    <script src="js/three.min.js"></script>

    <!-- https://unpkg.com/browse/three@0.124.0/examples/js/controls/OrbitControls.js -->
    <script src="js/OrbitControls.js"></script>

    <!-- https://unpkg.com/three@0.124.0/examples/js/renderers/CSS2DRenderer.js -->
    <script src="js/CSS2DRenderer.js"></script>

    <!-- Custom -->

    <script>

    let app = {

      options : {

        firstPerson : true

      },

      elements : {

        canvas : document.querySelector( '.canvas' ),
        trackButton : document.querySelector( '.track' ),

      },

      data : {

        orientation : {
          alpha : 0,
          beta  : 0,
          gamma : 0,
        },

        earth : {
          radius : {
            crust : 6371
          }
        }

      },

      three : {

        renderer       : undefined,
        camera         : undefined,
        scene          : undefined,
        controls       : undefined,

        tunnel         : undefined, // Group
        cylinder       : undefined,
        chord          : undefined,

        create : {

          cylinder : () => {

            let geometry = new THREE.CylinderGeometry(
              app.data.earth.radius.crust / 20,
              app.data.earth.radius.crust / 20,
              app.data.earth.radius.crust * 2,
              6,
              32
            );

            let material = new THREE.MeshBasicMaterial( {
                color: 0xff0000,
                wireframe: true,
                opacity: 1,
                transparent: true
            } );

            // Rotates around end, not center
            // app.three.tunnelGeometry.translate( 0, -app.data.earth.radius.crust, 0);

            app.three.cylinder = new THREE.Mesh( geometry, material );
            // app.three.tunnel.position.z = app.data.earth.radius.crust;

          },

          tunnel : () => {

            app.three.tunnel = new THREE.Group();

            app.three.tunnel.add(
              app.three.cylinder
            );

          },

          sphere : () => {

            // Applies satellite texture for debugging
            let texture = new THREE.TextureLoader().load( './../assets/texture.jpg' );

            let geometry = new THREE.SphereGeometry(
              app.data.earth.radius.crust * 0.99,
              16,
              16
            );

            let material = new THREE.MeshBasicMaterial( {
              color: 'gray',
              // wireframe: true,
              opacity: 0.75,
              transparent: true,
              map: texture
            } );

            // Allows raycaster to detect collision on both sides of the object
            material.side = THREE.DoubleSide;

            app.three.sphere = new THREE.Mesh( geometry, material );

          },

          renderer : () => {

            // Creates renderer with transparent background
            app.three.renderer = new THREE.WebGLRenderer( {
              canvas : app.elements.canvas,
              alpha : true,
              logarithmicDepthBuffer: true // prevents z fighting
            } );

          },

          camera : () => {

            // Creates camera
            app.three.camera = new THREE.PerspectiveCamera( 50, 1, .1, app.data.earth.radius.crust * 30 );
            app.three.camera.position.y = app.data.earth.radius.crust * 3;

          },

          controls : () => {

            // Makes camera move with mouse
            app.three.controls = new THREE.OrbitControls(
              app.three.camera,
              app.elements.canvas
            );

            // Makes camera move automatically and with inertia
            app.three.controls.enableDamping = true;
            app.three.controls.enableZoom    = false;
            app.three.controls.enablePan     = false;

          },

          scene : () => {

            // Creates scene
            app.three.scene = new THREE.Scene();
            app.three.scene.add(
              app.three.tunnel,
              app.three.sphere,
            );

          }

        },

        initialize : () => {

          // Creates Tunnel group
          app.three.create.cylinder();
          app.three.create.tunnel();


          app.three.create.sphere();

          app.three.create.renderer();
          app.three.create.camera();
          app.three.create.controls();
          app.three.create.scene();

          // Debugs axes
          app.three.scene.add( new THREE.AxesHelper( 1000 ) );

          // Animate 3D elements
          requestAnimationFrame( app.three.render );

        },

        render : ( time ) => {

          // Makes canvas responsive
          app.three.resize();

          // Enables first-person view
          if ( app.options.firstPerson ) {

            // Rotates Earth to always match real-world North
            app.three.sphere.rotation.y   = THREE.Math.degToRad( app.data.orientation.alpha * -1 );

            // Rotates tunnel only on two axes
            app.three.cylinder.rotation.x = THREE.Math.degToRad( app.data.orientation.beta  );
            app.three.tunnel.rotation.y   = THREE.Math.degToRad( 0 );
            app.three.cylinder.rotation.z = THREE.Math.degToRad( app.data.orientation.gamma );

          } else { // Enables third-person view

            // Keeps Earth still
            app.three.sphere.rotation.y   = THREE.Math.degToRad( 0 );

            // Rotates tunnel on all axes
            app.three.cylinder.rotation.x = THREE.Math.degToRad( app.data.orientation.beta  );
            app.three.tunnel.rotation.y   = THREE.Math.degToRad( app.data.orientation.alpha );
            app.three.cylinder.rotation.z = THREE.Math.degToRad( app.data.orientation.gamma );

          }




          /*
          // Rotates crust so default location is at latitude and longitude 0
          app.three.crust.rotation.y = THREE.Math.degToRad( -90 );

          // Rotates countries so default location is at latitude and longitude 0
          if ( app.three.land ) {
            app.three.land.rotation.y = THREE.Math.degToRad( -180 );

          }

          // Rotates crust & countries so it looks like the pivot point is the user location
          if ( app.data.user.latitude && app.data.user.longitude ) {

            // Crust
            app.three.crust.rotation.x = THREE.Math.degToRad( app.data.user.latitude );
            app.three.crust.rotation.y = THREE.Math.degToRad( -90 - app.data.user.longitude );

            // Countries
            if ( app.three.land ) {
              app.three.land.rotation.y = THREE.Math.degToRad( -180 - app.data.user.longitude );
            }

          }

          // Rotates Earth (group) to counter-act previous rotation so OrbitControls work better
          app.three.earth.rotation.x = THREE.Math.degToRad( - app.data.user.latitude );

          */




          // Makes camera orbit
          app.three.controls.update();

          app.three.renderer.render(
            app.three.scene,
            app.three.camera
          );

          // Enables recursion (this function calls itself to draw frames of 3D animation)
          requestAnimationFrame( app.three.render );

        },

        resize : () => {

          let c = app.elements.canvas;

          // If canvas dimensions are different from window dimensios
          if ( c.width !== c.clientWidth || c.height !== c.clientHeight ) {

            // Resizes
            app.three.renderer.setSize(
              c.clientWidth,
              c.clientHeight,
              false
            );

            // Updates camera accordingly
            app.three.camera.aspect = c.clientWidth / c.clientHeight;
            app.three.camera.updateProjectionMatrix();

          }

        }

      },

      orientation : {

        handle : () => {

          // Implements world-based calibration on iOS (alpha is 0 when pointing North), based on:
          // https://www.w3.org/2008/geolocation/wiki/images/e/e0/Device_Orientation_%27alpha%27_Calibration-_Implementation_Status_and_Challenges.pdf

          let north, offset;

          // If alpha is absolute (0 points North)
          if ( event.absolute === true ) {

            // Uses incoming value
            north = event.alpha;

          } else { // If alpha is relative

            // Calibrates alpha to make it North-based
            offset = event.webkitCompassHeading || 0;
            north  = 360 - offset;

            if ( north < 0 )
              north += 360;

          }

          // Prints values for debugging
          let pre = document.querySelector( 'pre' )

          pre.textContent = ''
          pre.textContent += 'north:    ' + north.toFixed(2) + '\n';
          pre.textContent += '\n';
          pre.textContent += 'alpha:    ' + event.alpha.toFixed(2) + '\n';
          pre.textContent += 'beta:     ' + event.beta.toFixed(2)  + '\n';
          pre.textContent += 'gamma:    ' + event.gamma.toFixed(2) + '\n';
          pre.textContent += '\n';
          pre.textContent += 'absolute: ' + event.absolute;
          pre.textContent += '\n';
          pre.textContent += 'webkitCompassHeading:  ' + event.webkitCompassHeading + '\n';
          pre.textContent += 'webkitCompassAccuracy: ' + event.webkitCompassAccuracy + '\n';


          // Updates values to be used by render method
          app.data.orientation.alpha = north;
          app.data.orientation.beta  = event.beta;
          app.data.orientation.gamma = event.gamma * -1;

        },

        request : () => {

          // Requests permission for iOS 13+ devices
          if ( DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === 'function' ) {

            DeviceMotionEvent.requestPermission()
            .then( response => {

              if ( response == 'granted' ) {

                // Enables orientationControl
                // app.options.orientationControl = true;
                // app.steps.next()

                window.addEventListener( 'deviceorientation', app.orientation.handle );

              }

            } );

          }

        }

      },

      events : {

        initialize : () => {

          // Tracks phone’s orientation when clicked
          app.elements.trackButton.addEventListener( 'click', app.orientation.request );

        }

      },

      initialize : () => {

        app.three.initialize();
        app.events.initialize();

      }

    }

    app.initialize();

    </script>

  </body>
</html>
